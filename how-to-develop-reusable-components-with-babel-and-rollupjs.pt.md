---
title: Como desenvolver componentes reutiliz√°veis utilizando Babel and RollupJS
date: '2018-09-26'
layout: post
draft: false
featured: false
tags:
  - javascript
  - rollup.js
image: ./images/20180926.jpg
---

No dia 10 de Outubro, tive o prazer de falar sobre componentes reutiliz√°veis utilizando a biblioteca Rollup.js, no meetup [React Open Source](https://www.meetup.com/React-Open-Source/), em Berlin. Tentei mostrar, de forma simples, o contexto da cria√ß√£o do conceito de m√≥dulos em JavaScript e fiz uma sess√£o de live coding, mostrando como criar e publicar componentes reutiliz√°veis. Assista ao v√≠deo completo no final desse post.

## Por que eu precisaria expor meus componentes?
Existem diversos motivos e exemplos de situa√ß√µes em que √© interessante criarmos componentes reutiliz√°veis. √â importante listarmos alguns deles:

### 1. Compartilhamento de componentes entre diferentes aplica√ß√µes
Esse √© o caso mais √≥bvio e mais comum. A ideia essencial da arquitetura de componentes √© criar partes reutiliz√°veis de c√≥digo. Um exemplo cl√°ssico de reutiliza√ß√£o √© a cria√ß√£o de componentes de UI que podem ser reutilizados em diferentes aplica√ß√µes.

### 2. Compartilhamento de configura√ß√£o
Um outro caso bastante comum de reutiliza√ß√£o acontece quando precisamos compartilhar configura√ß√µes entre projetos. Uma forma simples de fazer isso √© compilar as configura√ß√µes como componentes.

### 3. Cria√ß√£o de micro-services para aplica√ß√µes front-end
A arquitetura de micro-servi√ßos √© uma t√©cnica de desenvolvimento e deploy que utiliza servi√ßos com responsabilidades bem definidas e totalmente desacordados, facilitando a manuten√ß√£o e evolu√ß√£o do sistema. Essa abordagem tem se tornado comum em aplica√ß√µes front-end e a utiliza√ß√£o de componentes reutiliz√°veis √© uma forma de desenvolver micro-services.

## Como gerenciar encapsulamento e depend√™ncia em JavaScript?
Um princ√≠pio b√°sico para a cria√ß√£o de componentes independentes e reutiliz√°veis √© que os mesmos sejam encapsulados e que haja um bom gerenciamento de depend√™ncias. Para resolver esse problema, foi introduzido o conceito de m√≥dulos JavaScript. 

Inicialmente, eram utilizadas fun√ß√µes imediatamente executadas (IIFE) e o padr√£o ‚ÄúRevelling module‚Äù para a cria√ß√£o de componentes, como no exemplo a seguir:

<script src="https://gist.github.com/hugomn/0324b8515dddff5c4c30b18d581a1021.js"></script>

### CommonJS

Em Janeiro de 2009, por√©m, Kevin Danger iniciou o projeto de cria√ß√£o do CommonJS para que houvesse uma melhor padroniza√ß√£o de componentes JavaScript, principalmente para *scripts server-side*. O projeto foi inicialmente chamado de **ServerJS**. O projeto iniciou os conceitos de **require**, **exports** and **module**.

Por√©m em Maio de 2013, Isaac Z. Schlueter, autor do npm, gerenciador de pacotes do Node.js, disse que CommonJS estava sendo descontinuado pelo Node.js, e que seria evitado pelos mantenedores do projeto. Segue abaixo um exemplo de m√≥dulo utilizando CommonJS:

<script src="https://gist.github.com/hugomn/dd0ee6ab22228ad409311eccc91d14c4.js"></script>

<script src="https://gist.github.com/hugomn/4e386b62684967a4cd691a3e2d408a45.js"></script>

### Asynchronous Module Definition (AMD)

Como a implementa√ß√£o de CommonJS n√£o era compat√≠vel com os browsers, foi criada a defini√ß√£o de m√≥dulos ass√≠ncronos, ou AMD. A AMD foi criada para ser usada nos browsers para melhorar o tempo de startup das aplica√ß√µes, e tais m√≥dulos poderiam ser objetos, fun√ß√µes, construtores, strings, JSON, etc. Abaixo um exemplo de m√≥dulo AMD:

<script src="https://gist.github.com/hugomn/bd04b870151a2c1c61ca696ebfcff6d0.js"></script>

### M√≥dulos ES2015 

Os m√≥dulos ES2015 foram implementados na recente implementa√ß√£o ECMAScript 2015 do Javascript, e √© compat√≠vel com as abordagens **ass√≠ncrona** e **s√≠ncrona**. E tem uma grande vantagem: **√© JavaScript nativo!**. Por√©m n√£o est√° completamente dispon√≠vel em todos os browsers e para isso precisa de um **transpilador** como **Babel** por exemplo para a execu√ß√£o em browsers n√£o suportados.

<script src="https://gist.github.com/hugomn/8cf95a5619aac64bebd220abe21acf00.js"></script>

<script src="https://gist.github.com/hugomn/c7970afb33ff7a1af5b476a89a4a844b.js"></script>

Agora que vimos uma r√°pida introdu√ß√£o aos m√≥dulos em JavaScript, vamos entender como **Rollup.js** pode nos ajudar a compilar nossos componentes em componentes reutiliz√°veis.

## O que √© Rollup.js?
Rollup √© um *bundler* de m√≥dulos para JavaScript que compila partes pequenas de c√≥digo em algo maior e mais complexo, como uma biblioteca ou uma aplica√ß√£o. 

Voc√™ deve estar se perguntando? **Por que n√£o Webpack?** Webpack foi criado basicamente como um *bundler* para web applications, principalmente para resolver os problemas de *code-splitting* e gerenciamento de assets. Recentemente ambas biblioteca cresceram muito e s√£o capazes de resolver a maioria dos problemas, tanto para bibliotecas, quando para web applications. Por√©m, o senso comum entre os *bundlers* tem sido o seguinte:

> Para aplica√ß√µes completas, utilize **Webpack**. Para bibliotecas, utilize **Rollup.js**.

## Talk is cheap, show me the code
Vamos finalmente ao nosso exemplo. Nesse exemplo, irei utilizar um componente extremamente b√°sico em **React**. Criaremos um **Header**, e o compilaremos para que seja reutilizado em outros projetos! 

#### 1. Primeiro, instalamos Rollup.js globalmente

`npm install --global rollup`

#### 2. Agora, criamos nosso componente de cabe√ßalho b√°sico
Nosso componente ter√° apenas uma tag **<h1>**, e ser√° publicado no npm para que possa ser utilizado por outros projetos:

```javascript
// src/header.js
import React from "react";

const Header = function() {
  return <h1>Hello, DV!</h1>;
};

export default Header;
```

#### 3. Precisamos exportar nosso componente de Cabe√ßalho

```javascript
// src/main.js
import Header from "./header.js";

export default Header;

```

Como pretendemos utilizar m√≥dulos ES6, precisaremos instalar e configurar o **Babel** para que nosso componente seja corretamente compilado.

#### 4. Instalando e configurando o Babel

```shell
npm install --save-dev @babel/core @babel/cli @babel/present-env @babel/present-react
```

```javascript
// babel.config.js
const presets = [
  [
    "@babel/env",
    {
      modules: false
    }
  ],
  ["@babel/preset-react"]
];

module.exports = { presets };
```

Agora que j√° instalamos e configuramos o Babel, precisamos instalar o plugin para o **Rollup.js** que far√° a integra√ß√£o com **Babel**:

#### 5. Instalando o plugin do Babel para o Rollup.js

```shell
npm install --save-dev rollup-plugin-babel
```

```javascript
// rollup.config.js
import babel from "rollup-plugin-babel";

export default [
  {
    input: "src/main.js",
    output: {
      name: "reusableComponents",
      file: "dist/main.js",
      format: "iife"
    },
    external: ["react"],
    plugins: [
      babel({
        exclude: "node_modules/**"
      })
    ]
  }
];
```

Muita aten√ß√£o na linha **external: ["react‚Äù]**. Sem essa configura√ß√£o, o Rollup ir√° compilar todo o c√≥digo-fonte do React junto com seu componente.

Agora j√° podemos compilar nosso componente:

```shell
rollup -c
```

Ap√≥s compilado, seu biblioteca estar√° compilada e dispon√≠vel em **dist/main.js**. Como etapa final, precisamos apenas publicar seu componente no reposit√≥rio do npm, para que possa ser utilizado por outros projetos. 

#### 6. Publicando sua biblioteca no ppm

Antes de publicar sua biblioteca, voc√™ precisa ser logar no npm, e provavelmente precisar√° configurar as chaves SSH de sua conta. 

```shell
npm login
```

```shell
npm publish --access=public
```

Pronto! Ap√≥s publicado, sua biblioteca e seus componentes j√° estar√£o dispon√≠veis para serem usados via `npm install` em seus outros projetos. üéâ

#### 7. **Dica b√¥nus:** Usando `npm link` para configurar seu ambiente de desenvolvimento

Para evitar que voc√™ tenha que publicar e atualizar seu componente toda vez que fizer alguma altera√ß√£o, existe uma forma simples de referenciar seu componente localmente em seus projetos. 

	1. Em sua biblioteca, crie um link virtual utilizando o commando `npm link`.
	2. No projeto que utiliza sua biblioteca, execute o mesmo comando, agora referenciando a biblioteca, por exemplo: `npm link @hugomn/reusable-components`.

Pronto! Agora voc√™ tem um ambiente completo e simples para desenvolver seus componentes reutiliz√°veis. Espero que gostem e, por favor, enviem qualquer d√∫vida ou feedback que tiverem. ü§òüèª

## V√≠deo completo no YouTube
Abaixo est√£o o v√≠deo completo e os slides da apresenta√ß√£o que fiz (em ingl√™s) para o meetup React Open Source, no dia 10 de outubro de 2018, em Berlim.

<div class="container" style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; margin-bottom: 40px"><iframe src="https://www.youtube.com/embed/Dve_bYaAVZ0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

<div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.1987%;"><iframe src="//speakerdeck.com/player/95ae0fbc24be49d88f1a7a0b333e984f" style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" allowfullscreen scrolling="no"></iframe></div>